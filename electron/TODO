Here are **two copy-paste â€œCursor task specsâ€** (aka tasks you can hand to your agent). Theyâ€™re written to force **no dead UI**, **no mockups**, and **end-to-end wiring**.

---

# TASK 1 â€” Profile: Influcine Achievements + XP Grind System + Fetch/Link Memory Agent

## Role

You are the greatest product designer and senior engineer. Build a breathtaking, premium achievements system inside **Profile â†’ under the user profile**, with **XP grind/levels**, real data persistence, and zero placeholder UI. Preserve the current UI layout unless explicitly modified here.

## Non-Negotiables (Hard Rules)

1. **No mockups / no dead UI**: if itâ€™s visible, it works end-to-end.
2. **Every button** triggers real logic and updates real state.
3. **No stubs / TODOs** in production paths.
4. **Do not remove or rename existing working functions.** Add new code safely.
5. The feature must be testable from a fresh install: user can watch, earn XP, unlock achievements, see progress.

## UX Goal (What it should feel like)

* Like a premium game profile: **XP bar, level-up animations**, rarity tiers, badge grid, achievement detail view.
* Achievements are **not â€œone and doneâ€** only â€” they can have **tiers** (I, II, III, Master) that require grinding watch actions.
* Everything is **Influcine branded** (no external platform names).

## Feature Requirements

### A) Achievement Categories (must ship with these)

Implement these categories and initial achievements (exact text can be polished, but keep the meaning):

**ğŸ¿ Influcine Watch Achievements**

* â€œJust One More Sceneâ€ â€” Watched 3+ episodes in one sitting
* â€œInflucine Knows Meâ€ â€” Watched long enough for habits to form
* â€œAutoplay Victimâ€ â€” Let the next episode roll
* â€œIâ€™ll Stop After This Oneâ€ â€” Still watching 2 episodes later
* â€œCouch Mode Activatedâ€ â€” 4+ hours watched in a day

**ğŸ§  Relatable / Brain-Off Achievements**

* â€œI Wasnâ€™t Even Paying Attentionâ€ â€” Watched while multitasking
* â€œBackground Comfortâ€ â€” Replayed the same show again
* â€œStarted For Vibesâ€ â€” Finished something you donâ€™t remember starting
* â€œPlot? What Plot?â€ â€” 10+ episodes in 24 hours
* â€œI Just Like The Charactersâ€ â€” Finished without knowing the genre

**ğŸ˜´ Sleep-Deprived Tier**

* â€œSleep Is a Suggestionâ€ â€” Watching after midnight
* â€œTomorrow Me Will Be Madâ€ â€” Watching within 6 hours of an alarm
* â€œBarely Consciousâ€ â€” 15+ hours watched in 48 hours
* â€œSunrise Creditsâ€ â€” Finished an episode at dawn

**ğŸ­ Taste & Personality Achievements**

* â€œComfort Rewatcherâ€ â€” Rewatched a title multiple times
* â€œDrama Enjoyerâ€ â€” 5 drama titles watched
* â€œTwist Addictâ€ â€” 3 thrillers back-to-back
* â€œThis Is Artâ€ â€” Rated something a 10 immediately
* â€œMid But I Finishedâ€ â€” Finished a low-rated watch anyway

**ğŸ† Influcine Meta Achievements**

* â€œFirst Tasteâ€ â€” First badge unlocked
* â€œInflucine Regularâ€ â€” 10 achievements unlocked
* â€œBadge Collectorâ€ â€” 25 achievements unlocked
* â€œStats Checkerâ€ â€” Opened watch stats repeatedly
* â€œTouch Grassâ€ â€” Intentionally unobtainable (display as a â€œlocked foreverâ€ gag)

### B) XP + Leveling System (grindable)

Implement a real XP system that grows over time based on watch actions.

**XP Sources (minimum)**

* Episode completed: +X XP
* Movie completed: +Y XP
* Consecutive watch days (streak): daily bonus
* Finishing a season: big bonus
* Rewatch: reduced XP (anti-farm)

**Levels**

* Level increases based on total XP with a curve (ex: level = f(xp)).
* Show:

  * Current Level
  * XP progress bar to next level
  * XP gained â€œtoastâ€ or micro animation after watch events
  * Level-up moment (small but premium)

**Achievement Tiers**
For most achievements, implement tiers like:

* Tier I (unlock)
* Tier II (harder)
* Tier III (grind)
* Master (rare)

Example:

* â€œJust One More Sceneâ€

  * I: 3 episodes/session
  * II: 5 episodes/session
  * III: 8 episodes/session
  * Master: 12 episodes/session

Do this tier structure consistently (not necessarily the same numbers, but the idea).

### C) Badge Rarity + Visual Design

Implement rarity tiers and visuals:

* Common: soft gradient, simple icon
* Rare: glow ring + subtle pulse
* Legendary: shimmer/tilt animation
* Funny/Cursed: playful wobble / slightly crooked

**Badge shape options**: rounded square OR coin â€” pick one and apply consistently.

Achievements UI must include:

* Category sections
* Badge grid per category
* Locked vs unlocked states
* Progress rings/bars on tiered achievements
* Tap badge â†’ opens Achievement Detail (shows: name, icon, rarity, tier, progress, unlock history)
* Filter: All / Unlocked / Locked / In Progress
* Sort: Rarity / Progress / Recent

### D) Data Model + Persistence (must be real)

Add storage for:

* totalXP
* currentLevel
* streak info
* achievement progress per id
* unlocked tiers + timestamps
* last watch session metrics needed to compute achievements

Use your existing app storage approach (SQLite/local DB or your backend if already present) â€” but it must persist across restarts.

### E) â€œWatch Eventâ€ Pipeline Integration (no fake)

Achievements must be earned from real watch activity.
Wire into the actual watch tracking lifecycle:

* when playback starts
* when it crosses meaningful thresholds
* when a title completes
* session start/end
* day boundaries for streaks

If the app doesnâ€™t track these yet, you must implement the minimal watch tracking needed so achievements genuinely unlock.

---

## F) â€œShow Fetch Memory Agentâ€ (link caching + reliability)

Add a lightweight agent/service that makes fetching requested shows smoother and avoids redoing work.

**Goal**
When a user requests a show/movie, the agent fetches metadata/streams/links/providers and **remembers** which sources worked so next time itâ€™s instant and reliable.

**Hard Requirements**

* Cache key: (title + year + season/episode + provider) normalized.
* Store:

  * working link/source
  * last success timestamp
  * last failure timestamp + error
  * reliability score (success rate)
* Next time: try the best working source first.
* Auto fallback: if a source fails, try the next best.

**Behavior**

* Acts â€œlike a clockâ€: quiet, consistent, keeps flow smooth.
* Must not block UI. Use background tasks properly.
* Provide a small â€œSource: Verifiedâ€ tag when using a remembered working source.
* Provide a â€œReport broken linkâ€ action that lowers reliability score and triggers re-fetch.

**UI integration (minimal)**
Inside the show detail/play screen:

* â€œVerified Sourceâ€ indicator if from cache
* â€œRefresh sourcesâ€ button (real function)
* â€œReport brokenâ€ button (real function)

---

## Acceptance Criteria (must pass)

* User can watch content â†’ XP increases â†’ level progresses.
* At least 8 achievements can be unlocked in normal testing.
* Tiered achievements show progress + unlock tiers correctly.
* App restart keeps XP/level/achievement states.
* No visible button does nothing.
* Fetch memory agent reduces repeated fetch work and shows verified indicator when used.

---

## Deliverables

* Fully implemented feature in Profile section (under user profile).
* Any required new files, schemas, services, and UI components.
* A short README section describing:

  * How XP works
  * Achievement tiers
  * Source memory agent caching rules

---

# TASK 2 â€” Library Sidebar: Release Calendar (New Movies, New Shows, New Episodes)

## Role

Add a calendar feature under **Library in the sidebar** that helps people see:

* new movies coming out
* new shows coming out
* new episodes for followed shows
  This must be functional end-to-end (no mock calendar).

## Non-Negotiables

* No placeholder events.
* Must pull real data from the existing content API/provider your app already uses.
* If no provider exists yet, implement at least one real provider integration and persist results.

## UX Requirements

* Sidebar item: **Calendar**
* Calendar view modes:

  * Month grid (primary)
  * List view (upcoming releases)
* Filters:

  * Movies / Shows / Episodes
  * Followed only (toggle)
* Event cards show:

  * Title, type, date/time (if known)
  * Poster thumbnail
  * Season/Episode number when relevant
  * â€œAdd reminderâ€ (real function)
  * â€œOpen detailsâ€ (real function)

## Data Requirements

* Store releases locally (cache) so it loads fast.
* Refresh schedule:

  * On open
  * Pull-to-refresh
  * Periodic refresh (daily)

## Follow System Integration

If users â€œfollowâ€ a show in Influcine:

* Calendar highlights upcoming episodes for followed shows.
* Notifications/reminders:

  * Optional local reminder (if the app supports notifications)
  * â€œRemind meâ€ must actually schedule a reminder (or if notifications arenâ€™t in place yet, implement them).

## Acceptance Criteria

* Calendar displays real upcoming items.
* Clicking an event opens the correct title detail page.
* â€œRemind meâ€ works (creates a reminder/notification).
* No dead UI.

---

